/*
 * Copyright (c) 2025 S. Brett Sutton 2022+
 *
 * This software is licensed under the MIT License.
 * SPDX-License-Identifier: MIT
 */

import 'dart:convert';
import 'dart:io';

import 'package:dcli/dcli.dart';
import 'package:path/path.dart';
import 'package:pubspec_manager/pubspec_manager.dart';
// If you don't want YAML support, you can remove this import
// and the _maybeLoadYamlRestore() method below.
import 'package:yaml/yaml.dart' as yaml;

import '../script/flags.dart';
import '../util/completion.dart';
import '../util/exceptions.dart';
import 'commands.dart';

/// Restores original dependency constraints/sources for direct (non-dev) deps
/// using the restore file generated by `lock`.
///
/// Supported restore files (first match wins):
///  - pubspec.lock-restore.json
///  - pubspec.lock-restore.yaml
class UnlockCommand extends Command {
  static const _commandName = 'unlock';

  UnlockCommand() : super(_commandName);

  @override
  Future<int> run(List<Flag> selectedFlags, List<String> arguments) async {
    String targetPath;

    if (arguments.isEmpty) {
      targetPath = pwd;
    } else if (arguments.length != 1) {
      throw InvalidCommandArgumentException(
        'Expected a single project path or no project path. '
        'Found ${arguments.length} ',
      );
    } else {
      targetPath = arguments[0];
    }

    await _unlock(targetPath);
    return 0;
  }

  Future<void> _unlock(String targetPath) async {
    if (!exists(targetPath)) {
      throw InvalidCommandArgumentException(
          'The project path $targetPath does not exists.');
    }
    if (!isDirectory(targetPath)) {
      throw InvalidCommandArgumentException(
          'The project path must be a directory.');
    }

    final project = DartProject.fromPath(targetPath);
    final pathToProjectRoot = project.pathToProjectRoot;

    print('');
    print(orange('Unlocking ${canonicalize(pathToProjectRoot)} ...'));
    print('');

    final pubspec = PubSpec.load(directory: pathToProjectRoot);

    // Build a set of direct (non-dev) dependency names currently in pubspec.
    final directDepNames = <String>{};
    for (final dep in pubspec.dependencies.list) {
      directDepNames.add(dep.name);
    }

    // Load restore map.
    final restore = _loadRestoreMap(pathToProjectRoot);
    final restoreDeps =
        (restore['dependencies'] ?? <dynamic, dynamic>{}) as Map;

    if (restoreDeps.isEmpty) {
      throw ExitWithMessageException('''
No dependencies found in restore file.
Expected a map under key: dependencies''');
    }

    // Apply restore to matching direct deps only.
    var restored = 0;
    final missingInPubspec = <String>[];
    final extraneousInRestore = <String>[];

    // If the restore file references deps the pubspec no longer has,
    // we track them but do not add new entries (to avoid surprises).
    for (final entry in restoreDeps.entries) {
      final depName = entry.key as String;
      final spec = (entry.value ?? <dynamic, dynamic>{}) as Map;

      final isDirectNow = directDepNames.contains(depName);
      if (!isDirectNow) {
        extraneousInRestore.add(depName);
        continue;
      }

      // Only update if it exists as a direct dependency (not dev).
      if (pubspec.devDependencies.exists(depName)) {
        // We never touch dev_dependencies.
        continue;
      }

      // Remove existing entry then add restored definition.
      pubspec.dependencies.remove(depName);

      final skippedSdk = <String>{};
      final builder = _builderFromRestore(depName, spec);
      if (builder == null) {
        if ((spec['source'] ?? '').toString() == 'sdk') {
          skippedSdk.add(depName);
        }
        continue;
      }

      pubspec.dependencies.add(builder);
      restored++;
    }

    pubspec.save();

    print(green('Restored $restored direct package(s).'));

    if (extraneousInRestore.isNotEmpty) {
      print(orange('''
Note: ${extraneousInRestore.length} entr${extraneousInRestore.length == 1 ? 'y' : 'ies'} in the restore file
do not exist as direct dependencies in the current pubspec and were ignored:
  • ${extraneousInRestore.join('\n  • ')}'''));
    }

    if (missingInPubspec.isNotEmpty) {
      print(red('''
Warning: ${missingInPubspec.length} entr${missingInPubspec.length == 1 ? 'y' : 'ies'} could not be restored due to invalid/unsupported spec:
  • ${missingInPubspec.join('\n  • ')}'''));
    }
  }

  /// Loads the restore content into a `Map<String, dynamic>`.
  /// Prefers JSON; falls back to YAML.
  Map<String, dynamic> _loadRestoreMap(String projectRoot) {
    final jsonPath = join(projectRoot, 'pubspec.lock-restore.json');
    final yamlPath = join(projectRoot, 'pubspec.lock-restore.yaml');

    if (File(jsonPath).existsSync()) {
      final raw = File(jsonPath).readAsStringSync();
      try {
        final map = json.decode(raw);
        if (map is Map<String, dynamic>) {
          return map;
        }
        throw const FormatException('JSON root is not a map.');
      } on FormatException catch (e) {
        throw ExitWithMessageException(
            'Failed to parse $jsonPath as JSON: ${e.message}');
      }
    }

    if (File(yamlPath).existsSync()) {
      return _maybeLoadYamlRestore(yamlPath);
    }

    throw ExitWithMessageException('''
No restore file found.
Expected one of:
  • ${relative(jsonPath, from: projectRoot)}
  • ${relative(yamlPath, from: projectRoot)}''');
  }

  Map<String, dynamic> _maybeLoadYamlRestore(String yamlPath) {
    final text = File(yamlPath).readAsStringSync();
    final doc = yaml.loadYaml(text);

    dynamic toPlain(dynamic v) {
      if (v is yaml.YamlMap) {
        final m = <String, dynamic>{};
        for (final key in v.keys) {
          m[key.toString()] = toPlain(v[key]);
        }
        return m;
      } else if (v is yaml.YamlList) {
        return v.map(toPlain).toList();
      } else {
        return v;
      }
    }

    final plain = toPlain(doc);
    if (plain is! Map<String, dynamic>) {
      throw ExitWithMessageException(
        'Failed to parse $yamlPath: root is not a map.',
      );
    }
    return plain;
  }

  /// Builds a DependencyBuilder from a single dependency spec in the restore
  /// file. Expected shape (per dep):
  ///
  /// hosted:
  ///   { "source": "hosted", "constraint": ">=1.0.0 <2.0.0" }
  /// alt-hosted:
  ///   { "source": "hosted", "url": "https://alt", "constraint": "^1.2.3" }
  /// git:
  ///   { "source": "git", "url": "...", "ref": "main", "path": "subdir" }
  /// path:
  ///   { "source": "path", "path": "../local_pkg" }
  /// sdk:
  ///   { "source": "sdk", "sdk": "flutter" }
  /// Builds a DependencyBuilder using the same classes your LockCommand uses:
  /// - DependencyBuilderPubHosted
  /// - DependencyBuilderAltHosted
  /// - DependencyBuilderGit
  /// - DependencyBuilderPath
  ///
  /// SDK deps are skipped (LockCommand also doesn’t handle sdk deps).
  DependencyBuilder? _builderFromRestore(
      String name, Map<dynamic, dynamic> spec) {
    final source = (spec['source'] ?? '').toString().trim();

    switch (source) {
      case 'hosted':
        final constraint = (spec['constraint'] ?? '').toString().trim();
        if (constraint.isEmpty) {
          return null;
        }

        final hostedUrl = (spec['url'] ?? '').toString().trim();
        if (hostedUrl.isEmpty) {
          return DependencyBuilderPubHosted(
            name: name,
            versionConstraint: constraint,
          );
        } else {
          return DependencyBuilderAltHosted(
            name: name,
            hostedUrl: hostedUrl,
            versionConstraint: constraint,
          );
        }

      case 'git':
        final url = (spec['url'] ?? '').toString().trim();
        if (url.isEmpty) {
          return null;
        }
        final ref = spec['ref']?.toString();
        final path = spec['path']?.toString();
        return DependencyBuilderGit(name: name, url: url, ref: ref, path: path);

      case 'path':
        final path = (spec['path'] ?? '').toString().trim();
        if (path.isEmpty) {
          return null;
        }
        return DependencyBuilderPath(name: name, path: path);

      case 'sdk':
        // Your LockCommand throws on sdk deps; mirror that here by skipping
        // and letting the caller print a warning.
        return null;

      default:
        return null;
    }
  }

  @override
  String usage() => 'unlock [<project path>]';

  @override
  String description({bool extended = false}) => '''
Restores original version ranges and sources for direct (non-dev) dependencies,
reversing a prior `lock`. Reads the restore file generated by `lock`:

  • pubspec.lock-restore.json   (preferred)
  • pubspec.lock-restore.yaml   (fallback)

Only updates dependencies that currently exist as direct dependencies in
pubspec.yaml. Dev dependencies are not modified.
''';

  @override
  List<String> completion(String word) => completionExpandScripts(word);

  @override
  List<Flag> flags() => [];
}
