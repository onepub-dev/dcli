#! /usr/bin/env dcli
/* Copyright (C) S. Brett Sutton - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Brett Sutton <bsutton@onepub.dev>, Jan 2022
 */

// ignore_for_file: deprecated_member_use

import 'dart:async';
import 'dart:io';

/// dcli script generated by:
/// dcli create editor.dart
///
/// See
/// https://pub.dev/packages/dcli#-installing-tab-
///
/// For details on installing dcli.
///

Future<void> main() async {
  // await for each process to start
  //var dart = start('dart', ['--version']);
  // var dart = start('cat', ['/var/log/syslog']);
  // var head = start('head', ['-n', '5']);

  // await pipeTo2(dart, head);

  // TODO: restore
  // 'dart --version'.run;
  // ('dart --version' | 'cat').run;

  //Future.wait([dart.])
}

// ignore: unreachable_from_main
Future<void> pipeTo2(Future<Process> lhs, Future<Process> rhs) async {
  final lhsProcess = await lhs;
  final rhsProcess = await rhs;
  lhsProcess.stdout.listen(rhsProcess.stdin.add);
  //..onError()
  lhsProcess.stderr.listen(rhsProcess.stdin.add).onDone(() {
    rhsProcess.stdin.close();
  });

  rhsProcess.stdout.listen(stdout.add);
  rhsProcess.stderr.listen(stderr.add);

  await rhsProcess.stdin.done
      //ignore: avoid_types_on_closure_parameters
      .catchError((Object e) {
    // forget broken pipe after rhs terminates before lhs
  }, test: (e) => e is SocketException && e.osError!.message == 'Broken pipe');
}

// ignore: unreachable_from_main
Future<void> pipeTo(Future<Process> lhs, Future<Process> rhs) async {
  final complete = Completer<void>();
  print('pipeTo called');
  // wait for the lhs process to
  // start and then start piping its
  // output to the rhs process.
  // ignore: discarded_futures
  await lhs.then((lhsProcess) {
    // ignore: discarded_futures
    rhs.then<void>((rhsProcess) {
      // write stdout from lhs to stdin of rhs
      lhsProcess.stdout.listen((datum) {
        print('listen');
        rhsProcess.stdin.add(datum);
        print('listen written');
      }, onDone: () {
        print('done');
        complete.complete();
      }, // stdoutCompleter.complete(true),
          //ignore: avoid_types_on_closure_parameters
          onError: (Object e, StackTrace s) =>
              print('onError $e'), // stdoutCompleter.completeError(e),
          cancelOnError: true);

      // write stderr from lhs to stdin of rhs.
      lhsProcess.stderr.listen((datum) {
        print('listen: stderr');
        rhsProcess.stdin.add(datum);
        print('listen: stderr written');
      }, onDone: () {
        print('done err');
        if (!complete.isCompleted) {
          complete.complete();
        }
      }, // stdoutCompleter.complete(true),
          //ignore: avoid_types_on_closure_parameters
          onError: (Object e, StackTrace s) =>
              print('onError $e'), // stdoutCompleter.completeError(e),
          cancelOnError: true);

      // ignore: discarded_futures
      lhsProcess.exitCode.then((exitCode) {
        print('lhs exitCode=$exitCode');
      });

      // ignore: discarded_futures
      rhsProcess.exitCode.then((exitCode) {
        print('rhs exitCode=$exitCode');
      });
    });
  });

  await complete.future;
}

// ignore: unreachable_from_main
Future<Process> start(String command, List<String> args) async {
  final process = Process.start(
    command,
    args,
  );
  return process;
}
